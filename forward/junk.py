    # A = Dual([[1,2],
    #           [3,4]])
    # B = Dual([[5,2],
    #           [3,8]])
    # D = matrix_matrix_product(A,B)
    # print(D, np.matmul(A.real,B.real))
    # b = Dual([2,3])
    # print(A)
    # print(b)
    
    # z = matrix_vector_product(A,b)
    # print(z)
    
    
    # A = Dual(np.array([[1.,2.],
    #                    [3.,4.]]))
    # x = Dual(np.array([2.,3.]))
    # print(A*x)
    
    # x,y = Dual.from_array([[1,2,3],[2,3,4]])
    # # print(x)
    # # print(y)
    # z = dot_product(x,y)
    # print(z)
    
    # a = Dual(np.array([1,2,3]))
    # #print(a)
    # b = Dual(np.array([2,3,4]))
    # #print(b)
    # print(dot_product(a,b))
    
    # f_out = f(x)
    # print(f_out)
    
    
    
    
    # x = Dual(np.pi/2)
    # print(cos(x))
    # print(cos(np.pi/2))
    # d = Dual([1.,2.])
    # print(sin(d))
    
    # x = Dual(2,-1.5)
    # print(log(x, base=10))
    
    # print(evalf(sqrt(2)))
    
    
    # x,y = Dual.from_array([2, 4])
    # g_x = g(x,y)
    # print(g_x)
    
    # x = Dual(2)
    # print(x)
    
    # f_out = f(x)
    # print(f_out)
    
    
    # v = Dual.from_array([2])
    # print(v)
    # # print(x)
    # # print(y)
    # # print(z)
    
    # h_out = h(*v)
    
    # print(h_out)
    
    # print(h_out[0])
    # print(h_out[1])
    
    # jac = jacobian(h_out)
    
    # # dh1/dx, dh2/dx
    # print(jac[:,0])
    # # dh1/dx, dh1/dy, dh1/dz
    # print(jac[0,:])
    
    
    
    # print(val_and_grad(f,4.))
    # print(gradient_checker(f,4.))
    # print(val_and_grad(f,[1.,2.]))
    # print(gradient_checker(f,[1.,2.]))